<!DOCTYPE html>

<html lang="zh-CN">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>星汉 · 拟真流体</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;500;700&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/lucide@latest"></script>

    <style>

        body, html { margin: 0; padding: 0; overflow: hidden; background: #050505; width: 100%; height: 100%; }

        

        #canvas-container {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;

            background: radial-gradient(circle at 50% 60%, #1e293b 0%, #000000 80%);

            transition: background 1s ease;

        }

        .font-serif { font-family: 'Noto Serif SC', serif; }

        .font-calligraphy { font-family: 'Zhi Mang Xing', cursive; }

        

        /* 更加细腻的动画曲线 */

        .fade-enter { animation: fadeEnter 1s cubic-bezier(0.16, 1, 0.3, 1) forwards; opacity: 0; transform: translateY(15px); }

        @keyframes fadeEnter { to { opacity: 1; transform: translateY(0); } }

        /* 磨砂玻璃 Dock 栏 */

        .glass-dock {

            background: rgba(0, 0, 0, 0.3);

            backdrop-filter: blur(20px);

            -webkit-backdrop-filter: blur(20px);

            border: 1px solid rgba(255, 255, 255, 0.08);

            box-shadow: 0 20px 50px rgba(0,0,0,0.5);

        }

        .weather-btn { position: relative; transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); opacity: 0.6; }

        .weather-btn:hover { opacity: 1; background: rgba(255,255,255,0.05); }

        .weather-btn.active {

            opacity: 1;

            background: rgba(255, 255, 255, 0.15);

            box-shadow: 0 0 30px rgba(255, 255, 255, 0.05);

            transform: scale(1.1);

            border-radius: 16px;

        }

        /* 激活状态下的小光点 */

        .weather-btn.active::after {

            content: ''; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);

            width: 4px; height: 4px; background: #fff; border-radius: 50%;

            box-shadow: 0 0 10px #fff;

        }

        .vertical-text { writing-mode: vertical-rl; text-orientation: upright; letter-spacing: 0.5em; }

        @media (max-width: 768px) { 

            .vertical-text { writing-mode: horizontal-tb; letter-spacing: 0.2em; } 

        }

        

        /* 诗词容器的遮罩，制造若隐若现感 */

        .poem-mask {

            mask-image: radial-gradient(circle, black 60%, transparent 100%);

            -webkit-mask-image: radial-gradient(circle, black 60%, transparent 100%);

        }

    </style>

</head>

<body>

    <div id="canvas-container"></div>

    <!-- UI Layer -->

    <div class="absolute inset-0 z-10 flex flex-col justify-between p-6 md:p-12 pointer-events-none text-slate-100 select-none">

        

        <!-- Header -->

        <header class="flex justify-between items-start w-full fade-enter" style="animation-delay: 0.1s;">

            <div class="pointer-events-auto cursor-pointer group">

                <div class="flex items-center gap-2 opacity-40 text-xs tracking-[0.4em] uppercase mb-2 group-hover:text-amber-200 transition-colors">

                    <i data-lucide="map-pin" class="w-3 h-3"></i>

                    <span>CHANG'AN</span>

                </div>

                <h1 class="text-5xl md:text-7xl font-calligraphy tracking-widest text-white drop-shadow-2xl group-hover:scale-105 transition-transform origin-left">长安</h1>

            </div>

            <div class="text-right">

                <div class="opacity-40 text-xs tracking-[0.3em] mb-1">LUNAR</div>

                <div class="text-xl md:text-2xl font-serif font-light tracking-widest text-white/90">上元 · 夜</div>

            </div>

        </header>

        <!-- Center Poem -->

        <section class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 md:translate-x-0 md:left-auto md:right-24 md:top-1/2 w-full md:w-auto text-center md:text-left pointer-events-none z-0">

            <div id="poem-container" class="fade-enter flex flex-col md:flex-row-reverse gap-6 md:gap-16 items-center justify-center transition-all duration-1000 ease-out poem-mask" style="animation-delay: 0.2s;">

                <h2 class="vertical-text text-3xl md:text-5xl font-serif font-bold text-white drop-shadow-[0_4px_20px_rgba(0,0,0,0.5)] poem-line">

                    醉后不知天在水

                </h2>

                <h2 class="vertical-text text-3xl md:text-5xl font-serif font-bold text-white/70 drop-shadow-[0_4px_20px_rgba(0,0,0,0.5)] poem-line">

                    满船清梦压星河

                </h2>

            </div>

        </section>

        <!-- Bottom Weather Info -->

        <section class="absolute bottom-36 md:bottom-16 left-6 md:left-16 pointer-events-auto fade-enter" style="animation-delay: 0.3s;">

            <div class="flex items-end gap-4 group">

                <span id="temp-val" class="text-7xl md:text-9xl font-thin font-serif leading-none -ml-1 tracking-tighter text-white transition-all duration-700">18</span>

                <div class="flex flex-col pb-2 md:pb-6 gap-2 opacity-80">

                    <i id="weather-icon" data-lucide="moon" class="w-8 h-8 md:w-10 md:h-10 text-amber-100"></i>

                </div>

            </div>

            <div class="h-px w-16 bg-white/30 my-4"></div>

            <div class="flex flex-col gap-1 overflow-hidden h-20">

                <span id="weather-main" class="text-2xl md:text-3xl font-calligraphy tracking-widest text-white transform transition-transform duration-700">星河欲转</span>

                <span id="weather-sub" class="text-xs text-white/40 tracking-[0.2em] uppercase font-serif transform transition-transform duration-700 delay-100">Starry Night</span>

            </div>

        </section>

        <!-- Dock -->

        <nav class="absolute bottom-8 left-1/2 transform -translate-x-1/2 pointer-events-auto fade-enter w-full max-w-[320px] md:max-w-sm" style="animation-delay: 0.4s;">

            <div class="glass-dock rounded-full p-2 flex justify-between items-center w-full px-6">

                <button onclick="setMode(0)" class="weather-btn active w-10 h-10 md:w-12 md:h-12 flex items-center justify-center text-amber-100" title="晴空">

                    <i data-lucide="moon" class="w-5 h-5"></i>

                </button>

                <button onclick="setMode(1)" class="weather-btn w-10 h-10 md:w-12 md:h-12 flex items-center justify-center text-cyan-100" title="雨夜">

                    <i data-lucide="cloud-rain" class="w-5 h-5"></i>

                </button>

                <button onclick="setMode(2)" class="weather-btn w-10 h-10 md:w-12 md:h-12 flex items-center justify-center text-white" title="飞雪">

                    <i data-lucide="snowflake" class="w-5 h-5"></i>

                </button>

                <button onclick="setMode(3)" class="weather-btn w-10 h-10 md:w-12 md:h-12 flex items-center justify-center text-purple-100" title="劲风">

                    <i data-lucide="wind" class="w-5 h-5"></i>

                </button>

            </div>

        </nav>

    </div>

    <!-- ================= SHADERS ================= -->

    <!-- 1. 通用粒子引擎 (Stars / Snow / Wind) -->

    <script type="x-shader/x-vertex" id="v-particles">

        attribute float size;

        attribute float speed;     // 个体速度差异

        attribute float randomVal; // 随机种子

        varying float vAlpha;

        varying float vMode;       // 传给片元着色器以区分绘制形状

        uniform float uTime;

        uniform vec3 uMouse;

        uniform float uMode;       // 0:Stars, 1:Rain(BG), 2:Snow, 3:Wind

        // 简单的伪随机

        float rand(vec2 co){

            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);

        }

        void main() {

            vec3 pos = position;

            vMode = uMode;

            vAlpha = 1.0;

            // === Mode 0: 真实星空 (Real Stars) ===

            if (uMode < 0.5) {

                // 星星位置固定，不移动，只闪烁

                // 闪烁逻辑：基于时间的 sin 波，加上随机相位

                float twinkle = sin(uTime * 2.0 + randomVal * 10.0);

                twinkle = smoothstep(-0.2, 1.0, twinkle); // 让闪烁更锐利一点

                vAlpha = 0.3 + 0.7 * twinkle; // 基础亮度0.3

                // 视差微动 (Parallax) - 极微小的移动增加深邃感

                pos.x += (uMouse.x * 0.05 - pos.x) * 0.02 * (pos.z / 1000.0);

                pos.y += (uMouse.y * 0.05 - pos.y) * 0.02 * (pos.z / 1000.0);

            }

            // === Mode 1: 雨天背景 (Rain BG) ===

            else if (uMode < 1.5) {

                vAlpha = 0.0; // 通用粒子隐藏，完全交给 Rain Engine

            }

            // === Mode 2: 真实飞雪 (Real Snow) ===

            else if (uMode < 2.5) {

                // 下落逻辑

                float fallSpeed = 30.0 + speed * 40.0; // 差异化速度

                float yOffset = mod(uTime * fallSpeed, 1000.0);

                pos.y = 500.0 - yOffset;

                // 飘荡逻辑 (Turbulence)

                // 使用叠加的正弦波模拟复杂的空气流动

                float swayX = sin(uTime * 0.5 + pos.y * 0.005 + randomVal * 10.0) * 20.0; // 宏观风

                float swayZ = cos(uTime * 0.3 + pos.y * 0.004 + randomVal * 10.0) * 20.0;

                

                // 微观抖动 (Flutter) - 模拟雪花翻滚

                float flutter = sin(uTime * 3.0 + randomVal * 100.0) * 2.0;

                pos.x += swayX + flutter;

                pos.z += swayZ + flutter;

                // 鼠标风场 (Mouse Repel)

                float d = distance(pos.xy, uMouse.xy);

                if (d < 250.0) {

                    vec3 dir = normalize(pos - vec3(uMouse.xy, 0.0));

                    float force = (250.0 - d) / 250.0;

                    pos += dir * force * 120.0; // 强烈的推开效果

                }

            }

            // === Mode 3: 狂风 (Gale / Dust) ===

            else {

                // 强烈的水平运动

                float windSpeed = 200.0 + speed * 300.0;

                float xOffset = mod(uTime * windSpeed, 2000.0);

                pos.x = 1000.0 - xOffset; // 从右向左飞

                // 湍流 (Turbulence) - 上下剧烈抖动

                pos.y += sin(pos.x * 0.01 + uTime * 10.0) * 15.0;

                pos.y += sin(uTime * 20.0 + randomVal * 100.0) * 5.0; // 高频抖动

                vAlpha = 0.4 + 0.6 * sin(pos.x * 0.1); // 忽明忽暗

                

                // 鼠标交互

                 float d = distance(pos.xy, uMouse.xy);

                if (d < 150.0) {

                    // 漩涡效果

                    float angle = atan(pos.y - uMouse.y, pos.x - uMouse.x);

                    pos.y += sin(angle * 5.0 + uTime * 10.0) * 20.0;

                }

            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);

            

            // 距离衰减大小

            gl_PointSize = size * (300.0 / -mvPosition.z);

            

            // 狂风模式拉长粒子？在FS里做很难，这里简单增大尺寸

            if (uMode > 2.5) gl_PointSize *= 2.0;

            gl_Position = projectionMatrix * mvPosition;

        }

    </script>

    <script type="x-shader/x-fragment" id="f-particles">

        uniform sampler2D pointTexture; // 我们将生成一个程序化纹理

        varying float vAlpha;

        varying float vMode;

        void main() {

            // 1. 基础圆形

            vec2 coord = gl_PointCoord - vec2(0.5);

            float dist = length(coord);

            

            // 2. 形状控制

            float alpha = 0.0;

            

            // 雪花：极其柔和的雾状边缘

            if (vMode > 1.5 && vMode < 2.5) {

                if (dist > 0.5) discard;

                alpha = 1.0 - smoothstep(0.0, 0.5, dist); // 线性衰减

                alpha = pow(alpha, 1.5); // 更柔和

            } 

            // 狂风：类似烟尘

            else if (vMode > 2.5) {

                if (dist > 0.5) discard;

                alpha = 1.0 - smoothstep(0.2, 0.5, dist);

                alpha *= 0.5; // 半透明

            }

            // 星星：锐利核心 + 柔和光晕

            else {

                if (dist > 0.5) discard;

                // 核心

                float core = 1.0 - smoothstep(0.0, 0.1, dist);

                // 光晕

                float glow = 1.0 - smoothstep(0.0, 0.5, dist);

                alpha = core * 0.8 + glow * 0.4;

            }

            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vAlpha);

        }

    </script>

    <!-- 2. 雨水引擎 (Instanced Mesh) - 保持之前的优秀实现，微调参数 -->

    <script type="x-shader/x-vertex" id="v-rain">

        attribute vec3 instancePos;

        attribute float instanceSpeed;

        attribute float instanceHeight;

        varying float vOpacity;

        uniform float uTime;

        uniform vec3 uMouse;

        uniform float uGlobalOpacity;

        mat4 rotationZ(in float angle) {

            return mat4(cos(angle),-sin(angle),0,0, sin(angle),cos(angle),0,0, 0,0,1,0, 0,0,0,1);

        }

        void main() {

            vec3 pos = instancePos;

            float speed = 600.0 + instanceSpeed * 200.0; // 极快

            float yDrop = mod(uTime * speed, 1200.0);

            pos.y = 600.0 - yDrop;

            // 恒定倾斜 (Windy Rain)

            float xDrift = -yDrop * 0.2; 

            pos.x += xDrift;

            // 鼠标避雨 (Umbrella Effect)

            float d = distance(pos.xy, uMouse.xy);

            float lean = 0.0;

            if (d < 180.0) {

                float force = (180.0 - d) / 180.0;

                pos.x += (pos.x - uMouse.x) * force * 0.8;

                lean = (pos.x - uMouse.x) * force * 0.01; 

            }

            vec3 localPos = position; 

            localPos.y *= instanceHeight; // 拉长

            localPos.x *= 0.5; // 变细

            float slantAngle = 0.2 + lean; 

            vec4 finalPos = projectionMatrix * modelViewMatrix * (vec4(pos, 1.0) + rotationZ(slantAngle) * vec4(localPos, 0.0));

            gl_Position = finalPos;

            vOpacity = uGlobalOpacity;

        }

    </script>

    <script type="x-shader/x-fragment" id="f-rain">

        varying float vOpacity;

        void main() {

            // 纯白微蓝，高透明度，模拟高速运动的残影

            gl_FragColor = vec4(0.8, 0.9, 1.0, vOpacity * 0.4);

        }

    </script>

    <script>

        lucide.createIcons();

        let scene, camera, renderer;

        let particleSystem, rainSystem, meteorSystem;

        let uniformsParticles, uniformsRain;

        let meteors = [];

        

        // 初始化

        function init() {

            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();

            

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);

            camera.position.z = 800;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });

            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            createParticleSystem(); // Stars/Snow/Wind

            createRainSystem();     // Rain

            

            // Events

            window.addEventListener('resize', onResize);

            document.addEventListener('mousemove', onMove);

            document.addEventListener('touchmove', onTouch, { passive: false });

            animate();

        }

        // === 核心：多功能粒子系统 ===

        function createParticleSystem() {

            // 削减数量：适中就好

            const count = 6000; 

            const geo = new THREE.BufferGeometry();

            const pos = [], size = [], speed = [], randVal = [];

            for(let i=0; i<count; i++) {

                // 宽阔分布

                pos.push((Math.random()-0.5)*2000, (Math.random()-0.5)*1200, (Math.random()-0.5)*800);

                size.push(Math.random() * 4 + 2); // 基础大小

                speed.push(Math.random());        // 速度差异

                randVal.push(Math.random());      // 随机相位

            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

            geo.setAttribute('size', new THREE.Float32BufferAttribute(size, 1));

            geo.setAttribute('speed', new THREE.Float32BufferAttribute(speed, 1));

            geo.setAttribute('randomVal', new THREE.Float32BufferAttribute(randVal, 1));

            uniformsParticles = {

                uTime: { value: 0 },

                uMouse: { value: new THREE.Vector3(9999,9999,0) },

                uMode: { value: 0.0 } 

            };

            const mat = new THREE.ShaderMaterial({

                uniforms: uniformsParticles,

                vertexShader: document.getElementById('v-particles').textContent,

                fragmentShader: document.getElementById('f-particles').textContent,

                transparent: true,

                depthWrite: false,

                blending: THREE.AdditiveBlending

            });

            particleSystem = new THREE.Points(geo, mat);

            scene.add(particleSystem);

        }

        // === 雨水系统 ===

        function createRainSystem() {

            const count = 1200; // 也不要太多

            const baseGeo = new THREE.PlaneGeometry(0.5, 1.0); 

            

            uniformsRain = {

                uTime: { value: 0 },

                uMouse: { value: new THREE.Vector3(9999,9999,0) },

                uGlobalOpacity: { value: 0.0 }

            };

            const mat = new THREE.ShaderMaterial({

                uniforms: uniformsRain,

                vertexShader: document.getElementById('v-rain').textContent,

                fragmentShader: document.getElementById('f-rain').textContent,

                transparent: true,

                depthWrite: false,

                blending: THREE.AdditiveBlending,

                side: THREE.DoubleSide

            });

            rainSystem = new THREE.InstancedMesh(baseGeo, mat, count);

            

            const dummy = new THREE.Object3D();

            const speedAttr = [], heightAttr = [], posAttr = [];

            for(let i=0; i<count; i++) {

                const x = (Math.random()-0.5)*2000;

                const y = (Math.random()-0.5)*1200;

                const z = (Math.random()-0.5)*600 + 200;

                dummy.position.set(x,y,z);

                dummy.updateMatrix();

                rainSystem.setMatrixAt(i, dummy.matrix);

                

                speedAttr.push(Math.random());

                heightAttr.push(60.0 + Math.random() * 40.0); // 雨滴长度

                posAttr.push(x, y, z);

            }

            rainSystem.geometry.setAttribute('instancePos', new THREE.InstancedBufferAttribute(new Float32Array(posAttr), 3));

            rainSystem.geometry.setAttribute('instanceSpeed', new THREE.InstancedBufferAttribute(new Float32Array(speedAttr), 1));

            rainSystem.geometry.setAttribute('instanceHeight', new THREE.InstancedBufferAttribute(new Float32Array(heightAttr), 1));

            scene.add(rainSystem);

        }

        // === 额外：流星系统 (仅在晴天出现) ===

        function spawnMeteor() {

            if (uniformsParticles.uMode.value > 0.5) return; // 只有晴天有流星

            if (Math.random() > 0.05) return; // 稀有

            const geometry = new THREE.BufferGeometry();

            // 头部 + 尾巴

            const points = [];

            const startX = (Math.random() - 0.5) * 1000;

            const startY = (Math.random() - 0.5) * 800 + 200;

            points.push(new THREE.Vector3(startX, startY, -200));

            points.push(new THREE.Vector3(startX + 20, startY + 20, -200)); // 短线

            geometry.setFromPoints(points);

            const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });

            const meteor = new THREE.Line(geometry, material);

            

            // 动画数据

            meteor.userData = { 

                vel: new THREE.Vector3(-15 - Math.random()*10, -10 - Math.random()*10, 0), 

                life: 1.0 

            };

            scene.add(meteor);

            meteors.push(meteor);

        }

        function updateMeteors() {

            for (let i = meteors.length - 1; i >= 0; i--) {

                const m = meteors[i];

                m.position.add(m.userData.vel);

                m.userData.life -= 0.02;

                m.material.opacity = m.userData.life;

                if (m.userData.life <= 0) {

                    scene.remove(m);

                    meteors.splice(i, 1);

                }

            }

        }

        // === 交互与动画 ===

        function onResize() {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        let mouse = new THREE.Vector3(9999,9999,0);

        function updateMousePos(x, y) {

            const vec = new THREE.Vector3();

            vec.set((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1, 0.5);

            vec.unproject(camera);

            vec.sub(camera.position).normalize();

            const distance = -camera.position.z / vec.z;

            const pos = camera.position.clone().add(vec.multiplyScalar(distance));

            mouse.copy(pos);

        }

        function onMove(e) { updateMousePos(e.clientX, e.clientY); }

        function onTouch(e) { if(e.touches.length) updateMousePos(e.touches[0].clientX, e.touches[0].clientY); }

        function animate() {

            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            if(uniformsParticles) {

                uniformsParticles.uTime.value = time;

                // 鼠标平滑插值

                uniformsParticles.uMouse.value.lerp(mouse, 0.1);

            }

            if(uniformsRain) {

                uniformsRain.uTime.value = time;

                uniformsRain.uMouse.value.lerp(mouse, 0.1);

                

                // 平滑过渡雨的透明度

                const target = targetRainMode ? 1.0 : 0.0;

                uniformsRain.uGlobalOpacity.value += (target - uniformsRain.uGlobalOpacity.value) * 0.05;

            }

            spawnMeteor();

            updateMeteors();

            renderer.render(scene, camera);

        }

        // === UI 逻辑 ===

        let targetRainMode = false;

        window.setMode = function(mode) {

            // 1. 视觉模式切换 (Lerp Transition)

            const startMode = uniformsParticles.uMode.value;

            const endMode = parseFloat(mode);

            let startTime = null;

            

            function tween(ts) {

                if(!startTime) startTime = ts;

                let p = (ts - startTime) / 800; // 800ms 缓慢过渡

                if(p > 1) p = 1;

                uniformsParticles.uMode.value = startMode + (endMode - startMode) * p;

                if(p < 1) requestAnimationFrame(tween);

            }

            requestAnimationFrame(tween);

            // 2. 雨水系统开关

            targetRainMode = (mode === 1);

            // 3. UI 更新

            updateUI(mode);

        };

        function updateUI(mode) {

            document.querySelectorAll('.weather-btn').forEach((b,i) => {

                if(i===mode) b.classList.add('active'); else b.classList.remove('active');

            });

            const data = [

                {

                    bg: 'radial-gradient(circle at 50% 60%, #1e293b 0%, #000000 80%)',

                    t: '18', m: '星河欲转', s: 'Starry Night', i: 'moon',

                    p1: '醉后不知天在水', p2: '满船清梦压星河'

                },

                {

                    bg: 'linear-gradient(to bottom, #0f172a, #020617)',

                    t: '15', m: '巴山夜雨', s: 'Heavy Rain', i: 'cloud-rain',

                    p1: '君问归期未有期', p2: '巴山夜雨涨秋池'

                },

                {

                    bg: 'radial-gradient(circle at 50% 40%, #334155 0%, #0f172a 100%)',

                    t: '-5', m: '千山暮雪', s: 'Heavy Snow', i: 'snowflake',

                    p1: '柴门闻犬吠', p2: '风雪夜归人'

                },

                {

                    bg: 'linear-gradient(120deg, #1e1b4b, #000000)',

                    t: '09', m: '大风起兮', s: 'Gale / Dust', i: 'wind',

                    p1: '大风起兮云飞扬', p2: '威加海内兮归故乡'

                }

            ];

            

            const d = data[mode];

            const container = document.getElementById('canvas-container');

            const temp = document.getElementById('temp-val');

            const main = document.getElementById('weather-main');

            const sub = document.getElementById('weather-sub');

            const icon = document.getElementById('weather-icon');

            const pContainer = document.getElementById('poem-container');

            // 背景过渡

            container.style.background = d.bg;

            // 文字淡出

            temp.style.opacity = 0;

            main.style.opacity = 0; main.style.transform = 'translateY(10px)';

            sub.style.opacity = 0;

            pContainer.style.opacity = 0; pContainer.style.filter = 'blur(10px)';

            setTimeout(() => {

                temp.innerText = d.t;

                main.innerText = d.m;

                sub.innerText = d.s;

                icon.setAttribute('data-lucide', d.i);

                lucide.createIcons();

                pContainer.innerHTML = `

                    <h2 class="vertical-text text-3xl md:text-5xl font-serif font-bold text-white drop-shadow-[0_4px_20px_rgba(0,0,0,0.5)] poem-line">${d.p1}</h2>

                    <h2 class="vertical-text text-3xl md:text-5xl font-serif font-bold text-white/70 drop-shadow-[0_4px_20px_rgba(0,0,0,0.5)] poem-line">${d.p2}</h2>

                `;

                // 文字淡入

                temp.style.opacity = 1;

                main.style.opacity = 1; main.style.transform = 'translateY(0)';

                sub.style.opacity = 1;

                pContainer.style.opacity = 1; pContainer.style.filter = 'blur(0px)';

            }, 500);

        }

        init();

    </script>

</body>

</html>

